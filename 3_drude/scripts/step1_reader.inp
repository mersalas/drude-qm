* separating out segments from additive crd, writing individual
* crd files and generating corresponding Drude inputs
*

DIMENS CHSIZE 5000000 MAXRES 3000000

! Read topology and parameter files
stream toppar.str

! Read PSF and Coordinates
open read unit 10 card name 2_mph30.psf
read psf  unit 10 card

open read unit 10 card name 3_mph30.crd
read coor unit 10 card

coor orient mass norotation

! glycan segment
stream step1_reader_glycan.str

!set number of segments
set nsegid ?nseg
open writ unit 20 card name step1_reader_nseg.str
write title unit 20
* set nsegid @nsegid
*

set count 1

label loop_segid

   open writ unit 21 card name step1_reader_seg@count.str

   !obtain segment name
   coor stat sele all .subset. 1 end
   set segname ?selsegi

   define segment sele segid @segname end
   set natom = ?nsel
   define first sele .byres. ( segid @segname .subset. 1 ) end
   set firstrid = ?selresi
   set firstres = ?selresn
   define last  sele .byres. ( segid @segname .subset. @natom ) end
   set lastrid = ?selresi
   set lastres = ?selresn
   set is_carb = no

   ! rename TIP3 to SWM4
   define test sele segid @segname .and. resname TIP3 end
   if ?nsel .gt. 0 then
      rename RESN SWM4 sele test end
      set nter = none
      set cter = none
      set type = water
      goto skip_rename
   endif

   ! nucleic acid  !UMB: define it as RNA if O2' is present
   define test sele segid @segname .and. ( resname ADE .or. resname CYT .or. resname URA .or. resname GUA ) .and. type O2' end
   if ?nsel .gt. 0 then
      set nter = 5TER
      set cter = 3TER
      set type = RNA
      goto skip_rename
   endif

   ! nucleic DNA  !UMB: if it is RNA, this part will not be executed  
   define test sele segid @segname .and. ( resname ADE .or. resname CYT .or. resname THY .or. resname GUA ) end
   if ?nsel .gt. 0 then
      set nter = 5TER
      set cter = 3TER
      set type = DNA
      goto skip_rename
   endif

   define test sele segid @segname .and. .not. ( resname ALA .or. resname CYS .or. resname ASP .or. resname GLU .or. -
                                                 resname PHE .or. resname GLY .or. resname HIS .or. resname ILE .or. -
                                                 resname LYS .or. resname LEU .or. resname MET .or. resname HSD .or. -
                                                 resname HSE .or. resname HSP .or. resname ASN .or. resname PRO .or. -
                                                 resname GLN .or. resname ARG .or. resname SER .or. resname THR .or. -
                                                 resname SEC .or. resname VAL .or. resname TRP .or. resname TYR .or. -
                                                 resname ORN .or. resname DAB .or. resname DPP) end
   if ?nsel .eq. 0 then
      set type = protein

      set nter = 0
      define nter sele first .and. .bonded. type N .and. hydr show end
      if ?nsel .eq. 3 set nter = NTER
      define nter sele first .and. .bonded. type N .and. type CY show end
      if ?nsel .eq. 1 set nter = ACE
      define nter sele first .and. .bonded. type N .and. type C1 show end
      if ?nsel .eq. 1 set nter = MYRN
      if firstres .eq. GLY set nter = GNTE
      if firstres .eq. PRO then
         set nter = PROP
         rename atom HT1 sele resname PRO .and. type HN1 end
         rename atom HT2 sele resname PRO .and. type HN2 end
      endif
      !exit if N-terminal patch not identified
      if nter .eq. 0 then
        !N terminal patch not identified
        stop
      endif

      set cter = 0
      define cter sele  last .and. type OT2 end
      if ?nsel .ne. 0 then
         define cter sele last .and. .bonded. type OT2 .and. .not. type C end
         if ?nsel .eq. 0 set cter = CTER
         if ?nsel .ne. 0 if ?selchem .eq. H set cter = CNEU
         if ?nsel .ne. 0 if ?selchem .eq. CT3 set cter = CT1
      else
         define cter sele last .and. .bonded. type NT .and. .not. hydr .and. .not. type C end
         if ?nsel .eq. 0 set cter = CT2
         if ?nsel .ne. 0 then
            set cter = CT3
            rename atom HTC3 sele last .and. type HT3 end
         endif
         rename atom HTC1 sele last .and. type HT1 end
         rename atom HTC2 sele last .and. type HT2 end
      endif
      if lastres .eq. GLY set cter = CTEG
      if lastres .eq. PRO set cter = CTEP
      !exit if C-terminal patch not identified
      if cter .eq. 0 then
        !C terminal patch not identified
        stop
      endif

      if firstrid .eq. @lastrid then
        if nter .eq. NTER then
          if cter .eq. CTER then
            set nter = NTES
            set cter = CTES
          endif
        endif
      endif 

      ! rename ILE atoms from CD to CD1
      define test sele segid @segname .and. resname ILE .and. type CD end
      if ?nsel .gt. 0 rename ATOM CD1  sele test end
   
      define test sele segid @segname .and. resname ILE .and. type HD1 end
      if ?nsel .gt. 0 rename ATOM HD11  sele test end
   
      define test sele segid @segname .and. resname ILE .and. type HD2 end
      if ?nsel .gt. 0 rename ATOM HD12  sele test end
   
      define test sele segid @segname .and. resname ILE .and. type HD3 end
      if ?nsel .gt. 0 rename ATOM HD13  sele test end

      goto skip_rename
   endif

   ! carbohydrate?
   set i = 0
   if ncarb .gt. 0 then
      label do_carb
        incr i by 1
        if GLYCAN@@i .eq. @segname then
           set type = carb
           set nter = none
           set cter = none
           set Qpatch = yes
           set is_carb = yes
           goto skip_rename
        endif
      if i .lt. @ncarb goto do_carb
   endif

   set type = else
   set nter = none
   set cter = none

   label skip_rename

   ! obtain first residue name following renamin
   coor stat sele first end
   set rname ?selresn

   coor stat sele last end
   set cname ?selresn

   open write unit 10 card name step1_reader_seg@count.crd
   write coor card unit 10 sele segid @segname end

   ! write segid to stream file
   write title unit 21
   * set segname @segname
   * set rname @rname
   * set cname @cname
   * set nter @nter
   * set cter @cter
   * set type @type
   *

   if is_carb eq yes then
      write title unit 21
      * set Qpatch = yes
      *
      set 0 = @count
      set 1 = @segname
      system "sleep 2"
      system "mv step1_reader_patch_@1.str step1_reader_patch@0.str"
      system "sleep 2"
      goto end_patch
   endif


   !
   ! detect applied patches
   !

   set Qpatch = no

   ! disulfide bond
   define disu sele ( segid @segname .and. type SG ) .and. .bonded. type SG end
   if ?nsel .eq. 0 goto skip_disu
   scalar wmain set 0
   scalar wmain set 1 sele disu end
   calc ndisu = ?nsel / 2
   calc cnt = 1

   label loop_disu
      coor stat sele disu .and. prop wmain .eq. 1 end
      set resid1 = ?selresi
      set segid1 = ?selsegi
      scalar wmain set 0 sele bynum ?selatom end

      coor stat sele ( .bonded. ( bynum ?selatom ) ) .and. type SG end
      set resid2 = ?selresi
      set segid2 = ?selsegi
      scalar wmain set 0 sele bynum ?selatom end

      if Qpatch .eq. no then
         set Qpatch = yes
         write title unit 21
         * set Qpatch = yes
         *
      endif

      write title unit 22
      * patch DISU @segid1 @resid1 @segid2 @resid2 setup warn
      *

   incr cnt by 1
   if cnt .le. @ndisu goto loop_disu
   label skip_disu

   ! ASPP
   define aspp sele segid @segname .and. resn ASP end
   if ?nsel .eq. 0 goto skip_aspp
   calc nasp = ?nsel
   calc cnt = 1

   label loop_aspp
      define hd2 sele aspp .subset. @cnt .and. type hd2 end
      if ?nsel .ne. 0 then

         if Qpatch .eq. no then
            set Qpatch = yes
            write title unit 21
            * set Qpatch = yes
            *
         endif

         write title unit 22
         * patch ASPP ?selsegi ?selresi setup warn
         *
      endif

   incr cnt by 1
   if cnt .le. @nasp goto loop_aspp
   label skip_aspp

   ! GLUP
   define glup sele segid @segname .and. resn GLU end
   if ?nsel .eq. 0 goto skip_glup
   calc nglu = ?nsel
   calc cnt = 1

   label loop_glup
      define he2 sele glup .subset. @cnt .and. type he2 end
      if ?nsel .ne. 0 then

         if Qpatch .eq. no then
            set Qpatch = yes
            write title unit 21
            * set Qpatch = yes
            *
         endif

         write title unit 22
         * patch GLUP ?selsegi ?selresi setup warn
         *
      endif

   incr cnt by 1
   if cnt .le. @nglu goto loop_glup
   label skip_glup

   ! TP (phosphotyrosine)
   define tyr sele segid @segname .and. resn TYR end
   if ?nsel .eq. 0 goto skip_tyrp
   calc ntyr = ?nsel
   calc cnt = 1

   label loop_tyrp
      define tyrp sele tyr .subset. @cnt .and. type P* end
      if ?nsel .ne. 0 then
         set selsegi = ?selsegi
         set selresi = ?selresi

         set patch = TP1
         define h2 sele tyr .subset. @cnt .and. type H2 end
         if ?nsel .eq. 0 set patch = TP2

         if Qpatch .eq. no then
            set Qpatch = yes
            write title unit 21
            * set Qpatch = yes
            *
         endif
      
         write title unit 22
         * patch @patch @selsegi @selresi setup warn
         *

      endif

   incr cnt by 1
   if cnt .le. @ntyr goto loop_tyrp
   label skip_tyrp

   ! SP (phosphoserine)
   define ser sele segid @segname .and. resn SER end
   if ?nsel .eq. 0 goto skip_serp
   calc nser = ?nsel
   calc cnt = 1

   label loop_serp
      define serp sele ser .subset. @cnt .and. type P* end
      if ?nsel .ne. 0 then
         set selsegi = ?selsegi
         set selresi = ?selresi

         set patch = SP1
         define h2 sele ser .subset. @cnt .and. type HT end
         if ?nsel .eq. 0 set patch = SP2

         if Qpatch .eq. no then
            set Qpatch = yes
            write title unit 21
            * set Qpatch = yes
            *
         endif

         write title unit 22
         * patch @patch @selsegi @selresi setup warn
         *

      endif

   incr cnt by 1
   if cnt .le. @nser goto loop_serp
   label skip_serp

   ! THP (phosphothreonine)
   define thr sele segid @segname .and. resn THR end
   if ?nsel .eq. 0 goto skip_thrp
   calc nthr = ?nsel
   calc cnt = 1

   label loop_thrp
      define thrp sele thr .subset. @cnt .and. type P* end
      if ?nsel .ne. 0 then
         set selsegi = ?selsegi
         set selresi = ?selresi

         set patch = THP1
         define h2 sele thr .subset. @cnt .and. type HT end
         if ?nsel .eq. 0 set patch = THP2

         if Qpatch .eq. no then
            set Qpatch = yes
            write title unit 21
            * set Qpatch = yes
            *
         endif

         write title unit 22
         * patch @patch @selsegi @selresi setup warn
         *

      endif

   incr cnt by 1
   if cnt .le. @nthr goto loop_thrp
   label skip_thrp

   label end_patch

   bomlev -5
   dele atom sele segid @segname end
   bomlev 0

   if Qpatch .eq. no then
      write title unit 21
      * set Qpatch = no
      *
   endif

   if Qpatch .eq. yes then
      set 0 = @count
      system "sleep 2"
      system "mv fort.22 step1_reader_patch@0.str"
      close unit 22
      system "sleep 2"
   endif

calc count = @count + 1
if count le @nsegid goto loop_segid

stop
   
   
   
   
      
      
      						  
   						  
   


























